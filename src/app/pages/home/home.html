<section class="container page">
  <header class="page__header">
    <img ngSrc="/assets/logos/nano-studio-logo.svg" width="270" height="50" alt="Nano Studio" priority />
    <p class="text-md text-muted flex flex-row page__header__description">
      Generate product visuals with
      <span class="flex flex-row"><img ngSrc="/assets/logos/gemini-logo.svg" width="100" height="20" alt="Gemini" /> <b>Nano Banana</b></span>
    </p>
    <p class="text-md text-muted page__header__description__sub">
      Upload, describe the vibe, and go.
    </p>
  </header>

  <!-- ⭐ FLOATING UPDATE BOX ⭐ -->
  <div id="floating-update" class="floating-update" role="status" aria-live="polite" aria-atomic="true">
    <button id="floating-update-close" class="floating-update__close" aria-label="Dismiss update">✕</button>
    <div class="floating-update__content">
      <strong class="fw-semibold">Update</strong>
      <span id="floating-update-message" class="floating-update__message">
        Added random filenames.
      </span>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2 class="text-xl fw-semibold">Your product</h2>
      <div class="upload" role="group" aria-labelledby="upload-label" aria-describedby="upload-help">
        <label id="upload-label" class="fw-semibold">Upload photo (JPG or PNG)</label>
        <input
          #fileInput
          type="file"
          class="input"
          accept="image/png,image/jpeg"
          (change)="onFileChange(fileInput.files)"
        />
        <p id="upload-help" class="text-sm text-muted">Best results with clear, well-lit product images.</p>

        @if (filePreviewUrl()) {
          <div class="preview">
            <img [src]="filePreviewUrl()!" alt="Uploaded product preview" />
          </div>
        }
      </div>

      <div class="section">
        <label for="prompt" class="fw-semibold">Describe the vibe</label>
        <textarea
          #promptArea
          id="prompt"
          class="input textarea"
          [value]="prompt()"
          (input)="onPromptInput(promptArea.value)"
          placeholder="e.g. Soft natural light, wooden tabletop, cozy morning scene"
          rows="4"
        ></textarea>
      </div>

      <div class="section">
        <div class="fw-semibold">Quick prompts</div>
        <div class="chips">
          @for (preset of presets(); track preset) {
            <button
              type="button"
              class="chip"
              [class.chip--active]="selectedPreset() === preset.title"
              (click)="onSelectPreset(preset)"
            >{{ preset.title }}</button>
          }
        </div>
      </div>

      <div class="actions flex items-center gap-3">
        <button
          type="button"
          class="btn btn-primary"
          [disabled]="!canGenerate()"
          [attr.aria-busy]="loading()"
          (click)="generate()"
        >
          @if (loading()) { Visualizing... } @else { Generate image }
        </button>
      </div>
    </div>

    <div class="card">
      <h2 class="text-xl fw-semibold">Result</h2>
      @if (loading()) {
        <div class="loading-section">
          <div class="loading-spinner" aria-hidden="true"></div>
          <p class="loading-message text-md">{{ loadingMessagesService.currentMessage() }}</p>
        </div>
      } @else if (hasResult()) {
        <div class="result">
          <img [src]="resultUrl()!" alt="Generated image result" />
        </div>
        <div class="section">
          <a class="btn btn-secondary" [href]="resultUrl()!" (click)="downloadResult($event)">Download</a>
        </div>
      } @else {
        <p class="text-sm text-muted">Your generated image will appear here.</p>
      }
    </div>
  </div>

  <div class="footer text-muted">
    Made with ❤️ by <a href="https://github.com" target="_blank" rel="noopener">Saint</a>
  </div>
</section>

<!-- ⭐ FLOATING UPDATE CSS ⭐ -->
<style>
  .floating-update {
    position: fixed;
    top: 18px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1200;
    padding: 12px 18px;
    background: #fff;
    border-radius: 10px;
    border: 1px solid rgba(0,0,0,0.1);
    box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    transition: opacity 220ms ease;
  }

  .floating-update.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .floating-update__content {
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .floating-update__message {
    white-space: nowrap;
    max-width: 260px;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .floating-update__close {
    position: absolute;
    right: 6px;
    top: 6px;
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 4px;
    font-size: 15px;
  }
</style>

<!-- ⭐ FLOATING UPDATE JS ⭐ -->
<script>
(function () {
  // initial message shown on page load
  const INITIAL_MESSAGE = "Added random filenames.";

  // --- simple hash to create a stable localStorage key per message ---
  function hashString(s) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0).toString(36);
  }
  const LS_PREFIX = "floatingUpdate_v1:";

  function keyForMessage(msg) {
    return LS_PREFIX + hashString(String(msg || ""));
  }
  function isDismissed(msg) {
    try { return localStorage.getItem(keyForMessage(msg)) === "1"; } catch(e){ return false; }
  }
  function setDismissed(msg) {
    try { localStorage.setItem(keyForMessage(msg), "1"); } catch(e) {}
  }
  function clearDismissed(msg) {
    try { localStorage.removeItem(keyForMessage(msg)); } catch(e) {}
  }

  // Query elements (may return null if Angular hasn't rendered yet)
  function els() {
    return {
      box: document.getElementById("floating-update"),
      closeBtn: document.getElementById("floating-update-close"),
      msgEl: document.getElementById("floating-update-message")
    };
  }

  // Apply visibility & text when we have elements
  function apply(box, msgEl, message) {
    if (!box || !msgEl) return;
    msgEl.textContent = message;
    box.dataset.currentMessage = message;
    if (isDismissed(message)) {
      box.classList.add("hidden");
      box.setAttribute("aria-hidden", "true");
    } else {
      box.classList.remove("hidden");
      box.setAttribute("aria-hidden", "false");
    }
  }

  // Public function to set an update message (call from your Angular code)
  window.setUpdate = function (message) {
    if (typeof message !== "string") return;
    // When showing a new message, clear any existing dismissal for that message
    clearDismissed(message);
    const { box, msgEl } = els();
    if (box && msgEl) {
      apply(box, msgEl, message);
    } else {
      // store pending message - will be applied when element appears
      window.__pendingFloatingUpdateMessage = message;
    }
  };

  // Delegated click handler (works even if Angular replaces nodes)
  document.addEventListener("click", function (e) {
    const target = e.target;
    if (target && (target.id === "floating-update-close" || target.closest && target.closest("#floating-update-close"))) {
      const { box } = els();
      if (!box) return;
      const cur = box.dataset.currentMessage || INITIAL_MESSAGE;
      setDismissed(cur);           // persist dismissal for this exact message
      box.classList.add("hidden");
      box.setAttribute("aria-hidden", "true");
    }
  }, true);

  // Try to apply initial/pending message to the element; if not present yet, observe DOM
  function ensureApplied() {
    const pending = window.__pendingFloatingUpdateMessage;
    const messageToUse = (pending !== undefined ? pending : INITIAL_MESSAGE);
    const { box, msgEl } = els();
    if (box && msgEl) {
      apply(box, msgEl, messageToUse);
      return true;
    }
    return false;
  }

  // Set up MutationObserver to wait for Angular to render the floating node
  let observer;
  function waitForElementAndApply() {
    if (ensureApplied()) return; // already present
    if (observer) return; // already observing

    observer = new MutationObserver((mutations, obs) => {
      if (ensureApplied()) {
        obs.disconnect();
        observer = null;
      }
    });
    observer.observe(document.body, { childList: true, subtree: true });
    // safety retries in case Angular mounts later
    setTimeout(() => { if (observer) { ensureApplied(); } }, 300);
    setTimeout(() => { if (observer) { ensureApplied(); } }, 1200);
  }

  // On load attempt to apply (works if Angular already rendered)
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", waitForElementAndApply);
  } else {
    waitForElementAndApply();
  }

  // Expose small debug helper (optional)
  window.__floatingUpdate_debug = {
    isDismissed,
    setDismissed,
    clearDismissed,
    keyForMessage,
    pending: () => window.__pendingFloatingUpdateMessage
  };

  // Initialize pending message variable so setUpdate from other code can overwrite it
  if (window.__pendingFloatingUpdateMessage === undefined) {
    window.__pendingFloatingUpdateMessage = undefined;
  }
})();
</script>
